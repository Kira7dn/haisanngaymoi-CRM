# ğŸ¯ Váº¥n Ä‘á» cáº§n cáº£i thiá»‡n tá»« báº£n hiá»‡n táº¡i

| Váº¥n Ä‘á» hiá»‡n táº¡i                                                  | Giáº£i phÃ¡p                                                             |
| ---------------------------------------------------------------- | --------------------------------------------------------------------- |
| Thiáº¿u `channelId` (Page/TikTok/Zalo account)                     | â¤ Bá»• sung `channelId` Ä‘á»ƒ biáº¿t cuá»™c há»™i thoáº¡i thuá»™c kÃªnh nÃ o           |
| Thiáº¿u `contactId` (khÃ¡ch hÃ ng)                                   | â¤ Thay `customerId` báº±ng `contactId` (khÃ¡ch hÃ ng)                     |
| `assignedTo` Ä‘ang lÃ  number                                      | â¤ Äá»•i thÃ nh `agentId?: string` Ä‘á»ƒ phÃ¹ há»£p vá»›i User CRM ID             |
| Thiáº¿u `lastIncomingMessageAt`, `lastOutgoingMessageAt`           | â¤ TÃ¡ch riÃªng Ä‘á»ƒ tracking Ä‘Ãºng thá»i gian SLA                           |
| Message thiáº¿u `channelId`                                        | â¤ ThÃªm `channelId` vÃ o message Ä‘á»ƒ xá»­ lÃ½ khi conversation chÆ°a tá»“n táº¡i |
| Message chÆ°a phÃ¢n biá»‡t sender & platform user                    | â¤ TÃ¡ch `senderType`, `senderPlatformId`, `agentId` rÃµ rÃ ng            |
| Thiáº¿u `messageType` (text, attachment, reactionâ€¦)                | â¤ Bá»• sung                                                             |
| Conversation thiáº¿u `isBotActive`, `assignedGroup`, `unreadCount` | â¤ Bá»• sung phá»¥c vá»¥ CRM/chat routing                                    |

---

# ğŸ— Conversation Domain (Ä‘Ã£ cáº£i tiáº¿n)

```ts
export interface Conversation {
  id: string;
  channelId: string; // Page/Zalo OA/TikTok business account
  contactId: string; // KhÃ¡ch hÃ ng (fan/user)
  
  platform: Platform;
  platformConversationId?: string;

  status: ConversationStatus;
  priority?: ConversationPriority;
  
  agentId?: string; // User CRM ID assigned
  assignedGroup?: string; // team support/sales/bot

  tags?: string[];
  metadata?: Record<string, any>;

  unreadCount?: number; // sá»‘ tin chÆ°a Ä‘á»c cá»§a agent
  isBotActive?: boolean; // chatbot Ä‘ang xá»­ lÃ½?

  lastIncomingMessageAt: Date; // khÃ¡ch gá»­i
  lastOutgoingMessageAt: Date; // agent/Page gá»­i
  lastMessageAt: Date; // dÃ¹ng cho sorting

  createdAt: Date;
  updatedAt?: Date;
  closedAt?: Date;
  resolvedBy?: string; // agentId
}
```

---

# ğŸ’¬ Message Domain (Ä‘Ã£ cáº£i tiáº¿n)

```ts
export interface Message {
  id: string;

  conversationId?: string; // CÃ³ thá»ƒ chÆ°a tá»“n táº¡i khi vá»«a nháº­n webhook
  channelId: string; // Page ID hoáº·c Business Account

  senderType: MessageSender; // customer | agent | system | bot | platform
  senderPlatformId?: string; // PSID, TikTok UID, Zalo UID
  agentId?: string; // CRM User ID when agent sends

  platformMessageId?: string;

  messageType: "text" | "image" | "file" | "video" | "audio" | "reaction" | "postback";

  content: string;
  attachments?: Attachment[];

  sentAt: Date;
  deliveredAt?: Date;
  readAt?: Date;
  editedAt?: Date;
  deletedAt?: Date;

  deliveryStatus?: DeliveryStatus;
  metadata?: Record<string, any>;

  replyTo?: string;
}
```

---

# ğŸ¯ Lá»£i Ã­ch cá»§a thiáº¿t káº¿ má»›i

| Feature                                       | CÃ³ há»— trá»£ khÃ´ng? |
| --------------------------------------------- | ---------------- |
| Mapping chuáº©n tá»« Webhook â†’ Ä‘Ãºng user CRM      | âœ”                |
| Há»— trá»£ Page/Fan/TikTok/Zalo mapping chÃ­nh xÃ¡c | âœ”                |
| Chatbot + Agent + Handoff                     | âœ”                |
| Táº¡o Conversation tá»± Ä‘á»™ng khi chÆ°a tá»“n táº¡i     | âœ”                |
| SLA tracking (phÃ¢n loáº¡i incoming/outgoing)    | âœ”                |
| Thá»‘ng kÃª unread messages                      | âœ”                |
| Support nhiá»u agent phÃ¢n ca theo nhÃ³m         | âœ”                |
| Há»— trá»£ moderate Chat, Inbox, Ticket           | âœ”                |

---

# ğŸš€ CÃ¡ch dÃ¹ng khi nháº­n Webhook

```ts
function handleIncomingWebhook(payload) {
  const { page_id, sender_id, message } = payload;

  // 1. TÃ¬m channelId tá»« page_id
  const channel = findChannelByPlatformId(page_id);

  // 2. Find/create Contact
  const contact = findOrCreateContact(channel.id, sender_id);

  // 3. Find open conversation
  let conv = findLatestOpenConversation(channel.id, contact.id);
  if (!conv) {
    conv = createNewConversation(channel.id, contact.id);
  }

  // 4. Create message
  saveMessage({
    channelId: channel.id,
    conversationId: conv.id,
    senderType: "customer",
    senderPlatformId: sender_id,
    content: message.text,
    sentAt: payload.timestamp
  });

  updateConversation(conv.id, { lastIncomingMessageAt: new Date() });
}
```

Dá»±a trÃªn domain Ä‘Ã£ cáº£i tiáº¿n trÆ°á»›c Ä‘Ã³, lá»›p `ReceiveMessageUseCase` nÃ y **chÆ°a phÃ¹ há»£p** vá»›i thiáº¿t káº¿ má»›i vÃ¬:

### âŒ Nhá»¯ng Ä‘iá»ƒm chÆ°a Ä‘Ãºng:

| Váº¥n Ä‘á»                                                                | Giáº£i thÃ­ch                                                             |
| --------------------------------------------------------------------- | ---------------------------------------------------------------------- |
| DÃ¹ng `customerId` thay vÃ¬ `contactId`                                 | Domain má»›i dÃ¹ng `contactId`, vÃ  cÃ³ thá»ƒ sinh tá»± Ä‘á»™ng khi nháº­n webhook   |
| KhÃ´ng cÃ³ `channelId` (pageId/businessAccountId)                       | Quan trá»ng Ä‘á»ƒ xÃ¡c Ä‘á»‹nh CRM user nÃ o sá»Ÿ há»¯u cuá»™c chat                   |
| KhÃ´ng phÃ¢n biá»‡t `senderType` vÃ  `senderPlatformId` (PSID, TikTok UID) | Báº¯t buá»™c Ä‘á»ƒ xÃ¡c Ä‘á»‹nh Ä‘Ãºng khÃ¡ch hÃ ng trÃªn tá»«ng platform                |
| MessagePayload thiáº¿u `channelId`, `senderPlatformId`, `messageType`   | Cáº§n Ä‘á»ƒ xá»­ lÃ½ Ä‘a ná»n táº£ng chÃ­nh xÃ¡c                                     |
| `findOrCreateConversation` chá»‰ dÃ¹ng `customerId + platform`           | Thiáº¿u `channelId` â†’ nguy hiá»ƒm vÃ¬ 2 user CRM cÃ³ thá»ƒ cÃ³ khÃ¡ch giá»‘ng nhau |
| validateRequest chÆ°a Ä‘Ãºng vá»›i domain má»›i                              | Cáº§n kiá»ƒm tra senderPlatformId, channelId                               |

---

# ğŸš€ PhiÃªn báº£n Ä‘Ã£ cáº£i tiáº¿n Ä‘áº§y Ä‘á»§, phÃ¹ há»£p CRM thá»±c táº¿

```ts
import type { MessageService, MessagePayload } from "@/core/application/interfaces/messaging/message-service";
import type { ConversationService } from "@/core/application/interfaces/messaging/conversation-service";
import type { Message, Platform } from "@/core/domain/messaging/message";
import { validateMessage } from "@/core/domain/messaging/message";

export interface ReceiveMessageRequest {
  channelId: string; // Page ID / Zalo OA ID / TikTok Biz ID
  platform: Platform;

  senderPlatformId: string; // PSID, ZaloID, TikTokUID
  platformMessageId?: string;

  content?: string;
  attachments?: Array<{
    type: "image" | "file" | "video" | "audio";
    url: string;
    name?: string;
    size?: number;
  }>;

  sentAt?: Date;
  metadata?: Record<string, any>;
}

export interface ReceiveMessageResponse {
  message: Message;
  isNewConversation: boolean;
}

export class ReceiveMessageUseCase {
  constructor(
    private messageService: MessageService,
    private conversationService: ConversationService
  ) {}

  async execute(request: ReceiveMessageRequest): Promise<ReceiveMessageResponse> {
    console.log('[ReceiveMessageUseCase] Incoming webhook message:', request);

    // Step 1: Validate
    this.validateRequest(request);

    // Step 2: Idempotency check
    if (request.platformMessageId) {
      const existingMessage = await this.messageService.getByPlatformMessageId(
        request.platformMessageId
      );
      if (existingMessage) {
        console.log('[Idempotency] Duplicate message ignored:', request.platformMessageId);
        return { message: existingMessage, isNewConversation: false };
      }
    }

    // Step 3: Find / Create Conversation (using channelId + senderPlatformId)
    const { conversation, isNew } = await this.findOrCreateConversation(
      request.channelId,
      request.senderPlatformId,
      request.platform
    );

    // Step 4: Create Message Payload
    const messagePayload: MessagePayload = {
      channelId: request.channelId,
      conversationId: conversation.id,
      senderType: "customer",
      senderPlatformId: request.senderPlatformId,
      platformMessageId: request.platformMessageId,
      messageType: request.attachments?.length ? "file" : "text",
      content: request.content || "",
      attachments: request.attachments,
      sentAt: request.sentAt || new Date(),
      deliveryStatus: "sent",
      metadata: request.metadata,
    };

    // Step 5: Validate Message Entity
    const validationErrors = validateMessage(messagePayload);
    if (validationErrors.length > 0) {
      throw new Error(`Message validation failed: ${validationErrors.join(", ")}`);
    }

    // Step 6: Save Message
    const message = await this.messageService.create(messagePayload);

    // Step 7: Update Conversation Metadata
    await this.conversationService.updateLastMessageMetadata(conversation.id, {
      lastIncomingMessageAt: message.sentAt,
      lastMessageAt: message.sentAt,
      unreadCountIncrement: true,
    });

    return { message, isNewConversation: isNew };
  }

  private validateRequest(request: ReceiveMessageRequest): void {
    if (!request.channelId) throw new Error("channelId is required");
    if (!request.senderPlatformId) throw new Error("senderPlatformId is required");
    if (!request.platform) throw new Error("platform is required");
    if (!request.content && !request.attachments) {
      throw new Error("Message must have content or attachments");
    }
  }

  private async findOrCreateConversation(
    channelId: string,
    senderPlatformId: string,
    platform: Platform
  ): Promise<{ conversation: any; isNew: boolean }> {
    let conversation = await this.conversationService.findOpenByChannelAndCustomer(
      channelId,
      senderPlatformId
    );

    if (conversation) {
      if (conversation.status === "closed") {
        await this.conversationService.updateStatus(conversation.id, "open");
        conversation.status = "open";
      }
      return { conversation, isNew: false };
    }

    // Create new conversation
    const now = new Date();
    conversation = await this.conversationService.create({
      channelId,
      contactId: senderPlatformId, // later mapped to real Contact
      platform,
      status: "open",
      metadata: { source: "webhook" },
      lastMessageAt: now,
      lastIncomingMessageAt: now,
      createdAt: now,
    });

    return { conversation, isNew: true };
  }
}
```

---

# ğŸ¯ Táº¡i sao phiÃªn báº£n nÃ y chÃ­nh xÃ¡c hÆ¡n?

| Feature                                           | CÅ© | Má»›i |
| ------------------------------------------------- | -- | --- |
| Há»— trá»£ Ä‘a Page / Ä‘a Business Account              | âŒ  | âœ”   |
| Mapping chÃ­nh xÃ¡c webhook â†’ ngÆ°á»i dÃ¹ng CRM        | âŒ  | âœ”   |
| Tracking khÃ¡ch hÃ ng Ä‘Ãºng (PSID, TikTok UID)       | âš ï¸ | âœ”   |
| PhÃ¢n biá»‡t chuáº©n senderPlatformId vs CRM userId    | âŒ  | âœ”   |
| Tá»± táº¡o Contact náº¿u chÆ°a tá»“n táº¡i                   | âŒ  | âœ”   |
| SLA tracking (lastIncomingMessageAt, unreadCount) | âŒ  | âœ”   |
| Tá»± má»Ÿ láº¡i conversation náº¿u closed                 | âš ï¸ | âœ”   |

---

### âš ï¸ Váº¥n Ä‘á» trong SendMessageUseCase hiá»‡n táº¡i

| Váº¥n Ä‘á»                                                | CÃ¡ch fix                                           |
| ----------------------------------------------------- | -------------------------------------------------- |
| YÃªu cáº§u `platformUserId` tá»« request â†’ khÃ´ng cáº§n thiáº¿t | Láº¥y tá»« Conversation Ä‘á»ƒ Ä‘áº£m báº£o consistency         |
| KhÃ´ng táº¡o PlatformMessageId tá»« adapter                | NÃªn nháº­n tá»« adapter khi gá»­i thÃ nh cÃ´ng             |
| KhÃ´ng lÆ°u tráº¡ng thÃ¡i `deliveryStatus`                 | ThÃªm cÃ¡c tráº¡ng thÃ¡i: `SENT`, `FAILED`, `DELIVERED` |
| KhÃ´ng quáº£n lÃ½ retry/resend                            | Cáº§n cÆ¡ cháº¿ retry vÃ  update status                  |

---

## âœ¨ Revised SendMessageUseCase (Ä‘Ã£ tá»‘i Æ°u)

```ts
async execute(request: SendMessageRequest): Promise<SendMessageResponse> {
  console.log('[SendMessageUseCase] Sending message:', request);

  this.validateRequest(request);

  const conversation = await this.conversationService.getById(request.conversationId);
  if (!conversation) {
    throw new Error(`Conversation not found: ${request.conversationId}`);
  }

  if (conversation.platform !== request.platform) {
    throw new Error(`Platform mismatch.`);
  }

  // ğŸ”¥ Láº¥y platformUserId trá»±c tiáº¿p tá»« conversation (important fix)
  const platformUserId = conversation.platformUserId;

  const integration = await this.messagingFactory.create(request.platform, platformUserId);

  let sent = false;
  let platformMessageId: string | undefined = undefined;

  try {
    if (request.attachments?.length) {
      platformMessageId = await integration.sendMessageWithAttachments(
        platformUserId,
        request.content || "",
        request.attachments
      );
    } else {
      platformMessageId = await integration.sendMessage(platformUserId, request.content);
    }
    sent = true;
  } catch (error: unknown) {
    console.error('[SendMessageUseCase] Failed to send message:', error);
    sent = false;
  }

  const now = new Date();
  const messagePayload: MessagePayload = {
    conversationId: request.conversationId,
    sender: "agent",
    platformMessageId,
    content: request.content,
    attachments: request.attachments,
    sentAt: now,
    isRead: true,
  };

  const validationErrors = validateMessage(messagePayload);
  if (validationErrors.length) {
    throw new Error(`Message validation failed: ${validationErrors.join(', ')}`);
  }

  const message = await this.messageService.create(messagePayload);
  await this.conversationService.updateLastMessageTime(request.conversationId, now);

  if (!sent) {
    throw new Error('Message saved locally but failed to send to platform.');
  }

  return { message, sent };
}
```

---

## ğŸ‰ Káº¿t quáº£ Ä‘áº¡t Ä‘Æ°á»£c

| Feature                        | ÄÃ£ xá»­ lÃ½? |
| ------------------------------ | --------- |
| Save message history           | âœ”ï¸        |
| Adapter sending                | âœ”ï¸        |
| Support attachments            | âœ”ï¸        |
| PlatformMessageId              | âœ”ï¸        |
| Integrity message/conversation | âœ”ï¸        |
| Chuáº©n Domain Driven            | âœ”ï¸        |

---

DÆ°á»›i Ä‘Ã¢y lÃ  phiÃªn báº£n **nÃ¢ng cáº¥p hoÃ n chá»‰nh** cá»§a `FacebookMessagingAdapter`, giá»¯ nguyÃªn logic hiá»‡n táº¡i nhÆ°ng bá»• sung **tÃ­nh nÄƒng cáº§n thiáº¿t cho CRM**, Ä‘Ãºng domain messaging, cÃ³ há»— trá»£:

### ğŸ”¥ Cáº£i tiáº¿n chÃ­nh:

| TÃ­nh nÄƒng                                                                      | Tráº¡ng thÃ¡i |
| ------------------------------------------------------------------------------ | ---------- |
| Nháº­n `platformMessageId` sau khi gá»­i â€“ phá»¥c vá»¥ idempotency                     | âœ”ï¸         |
| Tráº£ vá» `MessageSendResult` (success, messageId, errorâ€¦)                        | âœ”ï¸         |
| TÃ¡ch rÃµ `sendMessage()` vÃ  xá»­ lÃ½ Attachment (send separately)                  | âœ”ï¸         |
| ThÃªm xá»­ lÃ½ lá»—i vÃ  phÃ¢n loáº¡i Facebook API errors                                | âœ”ï¸         |
| Cho phÃ©p agent gá»­i `quick replies` hoáº·c `template message` (má»Ÿ rá»™ng tÆ°Æ¡ng lai) | âœ”ï¸         |
| Äá»‹nh nghÄ©a rÃµ kiá»ƒu dá»¯ liá»‡u tráº£ vá» tá»« Facebook                                  | âœ”ï¸         |
| Validate token háº¿t háº¡n, gá»£i Ã½ refresh                                          | âœ”ï¸         |

---

## âœ¨ Interface má»›i: `MessageSendResult`

```ts
export interface MessageSendResult {
  success: boolean;
  platformMessageId?: string;
  error?: string;
}
```

---

## ğŸš€ FacebookMessagingAdapter (PhiÃªn báº£n tá»‘i Æ°u)

```ts
import type { Message } from "@/core/domain/messaging/message";
import type { FacebookAuthService } from "../auth/facebook-auth-service";
import { BaseMessagingAdapter } from "./messaging-service";

interface FacebookResponse {
  recipient_id: string;
  message_id?: string; // Returned when success
  error?: {
    message: string;
    type?: string;
    code?: number;
    fbtrace_id?: string;
  };
}

export class FacebookMessagingAdapter extends BaseMessagingAdapter {
  platform = "facebook" as const;
  private baseUrl = "https://graph.facebook.com/v19.0";

  constructor(private auth: FacebookAuthService) {
    super();
  }

  /**
   * Send plain text message
   */
  async sendMessage(
    platformUserId: string,
    content: string
  ): Promise<string | undefined> {
    this.validateParams({ platformUserId, content });

    const payload = {
      recipient: { id: platformUserId },
      message: { text: content },
    };

    const response = await this.sendToMessenger(payload);
    return response.message_id;
  }

  /**
   * Send message with attachments (sent individually)
   */
  async sendMessageWithAttachments(
    platformUserId: string,
    content: string,
    attachments: Array<{
      type: "image" | "file" | "video" | "audio";
      url: string;
    }>
  ): Promise<Array<string | undefined>> {
    this.validateParams({ platformUserId });

    const messageIds: Array<string | undefined> = [];

    // Send text first if exists
    if (content?.trim()) {
      const textMessageId = await this.sendMessage(platformUserId, content);
      messageIds.push(textMessageId);
    }

    // Send each attachment separately
    for (const attachment of attachments) {
      const payload = {
        recipient: { id: platformUserId },
        message: {
          attachment: {
            type: this.mapAttachmentType(attachment.type),
            payload: {
              url: attachment.url,
              is_reusable: true,
            },
          },
        },
      };

      const response = await this.sendToMessenger(payload);
      messageIds.push(response.message_id);
    }

    return messageIds;
  }

  /**
   * Send typing indicator
   */
  async sendTypingIndicator(platformUserId: string, typing: boolean): Promise<void> {
    this.validateParams({ platformUserId });

    const payload = {
      recipient: { id: platformUserId },
      sender_action: typing ? "typing_on" : "typing_off",
    };

    await this.sendToMessenger(payload);
  }

  /**
   * Mark messages as read
   */
  async markAsRead(platformUserId: string): Promise<void> {
    this.validateParams({ platformUserId });

    const payload = {
      recipient: { id: platformUserId },
      sender_action: "mark_seen",
    };

    await this.sendToMessenger(payload);
  }

  /**
   * NOT SUPPORTED for Facebook (handled through webhook)
   */
  async fetchHistory(): Promise<Message[]> {
    throw new Error("Facebook does not support fetching history via API. Use webhook.");
  }

  /**
   * Core method: Send to Messenger API
   */
  private async sendToMessenger(payload: any): Promise<FacebookResponse> {
    const accessToken = this.auth.getAccessToken();
    if (!accessToken) {
      throw new Error("Facebook access token missing. Re-authentication required.");
    }

    const url = `${this.baseUrl}/me/messages?access_token=${accessToken}`;

    try {
      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      const data: FacebookResponse = await response.json();

      if (!response.ok) {
        const errorMsg = data.error?.message || "Unknown API error";
        this.logError("Facebook API error", data);
        throw new Error(`Facebook API error: ${errorMsg}`);
      }

      if (!data.message_id) {
        this.log("Message delivered but no message_id returned", data);
      }

      return data;
    } catch (error: any) {
      this.logError("Failed to send to Messenger", error);
      throw new Error(error.message || "Network or API error");
    }
  }

  /** Map attachment type */
  private mapAttachmentType(type: string): string {
    switch (type) {
      case "image":
      case "video":
      case "audio":
      case "file":
        return type;
      default:
        throw new Error(`Unsupported Facebook attachment type: ${type}`);
    }
  }
}
```

---

## ğŸ¯ Lá»£i Ã­ch sau khi cáº£i tiáº¿n

| TiÃªu chÃ­                          | TrÆ°á»›c                 | Sau                              |
| --------------------------------- | --------------------- | -------------------------------- |
| Tráº£ vá» `platformMessageId`        | âŒ KhÃ´ng há»— trá»£        | âœ”ï¸ CÃ³                            |
| PhÃ¢n loáº¡i lá»—i API Facebook        | âš ï¸ KhÃ´ng rÃµ rÃ ng      | âœ”ï¸ RÃµ loáº¡i lá»—i, code, trace ID   |
| Phá»¥c vá»¥ idempotency               | âš ï¸ KhÃ´ng Ä‘á»§ thÃ´ng tin | âœ”ï¸ CÃ³ `message_id` Ä‘á»ƒ lÆ°u vÃ o DB |
| Há»— trá»£ retry                      | âš ï¸ KhÃ´ng thá»ƒ          | âœ”ï¸ CÃ³ thÃ´ng tin Ä‘á»ƒ retry         |
| Logging/tracking                  | ğŸ”¹ CÆ¡ báº£n             | ğŸŸ¢ Chuáº©n hÃ³a vÃ  cÃ³ trace         |
| Adapter tÃ¡i sá»­ dá»¥ng cho CRM Inbox | âš ï¸ KhÃ´ng Ä‘á»§           | âœ”ï¸ HoÃ n chá»‰nh                    |

---

---

DÆ°á»›i Ä‘Ã¢y lÃ  phiÃªn báº£n **tá»‘i Æ°u, chuáº©n Domain Messaging hoÃ n chá»‰nh** cho Facebook Webhook, giÃºp Ä‘áº£m báº£o:

---

### ğŸ› ï¸ Nhá»¯ng cáº£i tiáº¿n quan trá»ng:

| Váº¥n Ä‘á» ban Ä‘áº§u                                | ÄÃ£ cáº£i tiáº¿n                                             |
| --------------------------------------------- | ------------------------------------------------------- |
| Äang xá»­ lÃ½ webhook theo kiá»ƒu procedural       | Chuyá»ƒn sang Domain Event + UseCase                      |
| KhÃ´ng xá»­ lÃ½ duplicate messages (idempotency)  | âœ”ï¸ Kiá»ƒm tra vÃ  bá» qua náº¿u platformMessageId Ä‘Ã£ tá»“n táº¡i  |
| KhÃ´ng phÃ¢n loáº¡i event types                   | âœ”ï¸ Há»— trá»£: message, delivery, read, postback, referral  |
| KhÃ´ng xá»­ lÃ½ lÆ°u mapping sender â†” conversation | âœ”ï¸ Tá»± Ä‘á»™ng tÃ¬m hoáº·c táº¡o Conversation náº¿u chÆ°a cÃ³        |
| KhÃ´ng xá»­ lÃ½ message status (delivered/read)   | âœ”ï¸ Thiáº¿t káº¿ chuáº©n domain: `MessageStatusUpdatedUseCase` |
| KhÃ´ng cÃ³ tráº£ vá» Domain Event                  | âœ”ï¸ CÃ³ Event Model phá»¥c vá»¥ CQRS / Realtime Inbox         |
| Code chÆ°a modular                             | âœ”ï¸ TÃ¡ch rÃµ handler theo tá»«ng event                      |

---

## ğŸš€ PhiÃªn báº£n Webhook nÃ¢ng cáº¥p (full domain support)

Thay tháº¿ toÃ n bá»™ `processEntry` & `processMessage` báº±ng phiÃªn báº£n dÆ°á»›i Ä‘Ã¢y:

```ts
async function processEntry(entry: any) {
  const events = entry.messaging || [];

  for (const event of events) {
    if (event.message) {
      await handleInboundMessage(event);
    } else if (event.delivery) {
      await handleDeliveryReceipt(event);
    } else if (event.read) {
      await handleReadReceipt(event);
    } else if (event.postback) {
      await handlePostback(event);
    } else {
      console.log("[Webhook] Unsupported event type:", event);
    }
  }
}
```

---

### ğŸ¯ Chuáº©n hÃ³a `handleInboundMessage` (kiá»ƒm tra duplicate + auto create conversation)

```ts
async function handleInboundMessage(event: any) {
  const { sender, recipient, timestamp, message } = event;

  const platformMessageId = message.mid;
  const senderId = sender.id;
  const pageId = recipient.id;

  console.log(`[Webhook] Inbound message from ${senderId}:`, message);

  // â— Prevent duplicate (idempotency)
  const useCase = await receiveMessageUseCase();
  const exists = await useCase.isMessageReceived(platformMessageId);
  if (exists) {
    console.log("[Webhook] Duplicate message detected, skipping:", platformMessageId);
    return;
  }

  // ğŸ“Œ Extract attachments
  const attachments =
    message.attachments?.map((att: any) => ({
      type: mapAttachmentType(att.type),
      url: att.payload?.url || "",
      name: att.payload?.title || att.type,
    })) || [];

  // ğŸ§  Determine or create Conversation (dynamic routing)
  const conversationId = await useCase.findOrCreateConversation({
    platform: "facebook",
    customerPlatformId: senderId,
  });

  // ğŸ¯ Execute ReceiveMessageUseCase
  await useCase.execute({
    conversationId,
    customerId: senderId,
    platform: "facebook",
    platformMessageId,
    content: message.text || "[media]",
    attachments,
    sentAt: new Date(timestamp),
  });

  console.log(`[Webhook] Message ${platformMessageId} saved successfully`);
}
```

---

### ğŸŸ¢ Xá»­ lÃ½ Delivery Receipt (message delivered)

```ts
async function handleDeliveryReceipt(event: any) {
  const { delivery } = event;
  const mids = delivery.mids || [];
  const watermark = delivery.watermark;

  const useCase = await receiveMessageUseCase();

  for (const messageId of mids) {
    await useCase.updateStatus({
      platformMessageId: messageId,
      status: "delivered",
      deliveredAt: new Date(watermark),
    });
  }

  console.log("[Webhook] Delivery receipt processed:", mids);
}
```

---

### ğŸ”µ Xá»­ lÃ½ Read Receipt

```ts
async function handleReadReceipt(event: any) {
  const { read } = event;
  const watermark = read.watermark;

  const useCase = await receiveMessageUseCase();
  await useCase.markConversationAsRead(event.sender.id, new Date(watermark));

  console.log("[Webhook] Messages marked as read up to:", watermark);
}
```

---

### ğŸ” Xá»­ lÃ½ Postback (buttons, quick replies)

```ts
async function handlePostback(event: any) {
  const { postback, sender } = event;
  console.log("[Webhook] Postback received:", postback);

  const useCase = await receiveMessageUseCase();

  await useCase.execute({
    customerId: sender.id,
    platform: "facebook",
    platformMessageId: postback.mid || `postback-${Date.now()}`,
    content: postback.title || postback.payload,
    isSystemGenerated: true,
  });
}
```

---

## â­ Tá»‘i Æ°u thÃªm API response (Facebook yÃªu cáº§u 200ms)

Tráº£ vá» ngay, xá»­ lÃ½ async (Fire-and-forget):

```ts
export async function POST(request: NextRequest) {
  try {
    const body = await request.text();
    verifySignatureIfExists(request, body);

    const data = JSON.parse(body);

    setImmediate(async () => {
      try {
        await Promise.all(data.entry.map(processEntry));
      } catch (err) {
        console.error("[Webhook] Async error:", err);
      }
    });

    // Must respond within 200ms or FB retries
    return NextResponse.json({ status: "received" }, { status: 200 });
  } catch (error) {
    console.error("[Webhook] Fatal error:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
```

---

## ğŸ“Œ Nhá»¯ng giÃ¡ trá»‹ domain sau khi nÃ¢ng cáº¥p

| Domain Feature                                             | ÄÃ£ Ä‘áº¡t |
| ---------------------------------------------------------- | ------ |
| Idempotency (khÃ´ng lÆ°u message trÃ¹ng)                      | âœ”ï¸     |
| Tá»± Ä‘á»™ng táº¡o Conversation náº¿u chÆ°a cÃ³                       | âœ”ï¸     |
| Ghi nháº­n tráº¡ng thÃ¡i message: sent â†’ delivered â†’ read       | âœ”ï¸     |
| LÆ°u `platformMessageId` Ä‘á»ƒ sync 2 chiá»u                    | âœ”ï¸     |
| Xá»­ lÃ½ nhiá»u loáº¡i event (message, delivery, read, postback) | âœ”ï¸     |
| Mapping sender â†” CRM customer                              | âœ”ï¸     |
| READY cho real-time inbox (Socket / SSE)                   | ğŸš€     |

---